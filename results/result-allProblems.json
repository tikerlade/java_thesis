{"version":"3","listProblem":[{
  "tool": "Code Inspection",
  "category": "Initialization",
  "type": "Double brace initialization",
  "severity": "High",
  "comment": "Double brace initialization",
  "detailsInfo": "Reports [Double Brace Initialization](https://www.c2.com/cgi/wiki?DoubleBraceInitialization).\n\nDouble brace initialization may cause memory leaks when used in a non-static context because it creates an anonymous class\nthat will reference the surrounding object.\n\nCompared to regular initialization, double brace initialization provides worse performance since it requires loading an\nadditional class.\n\nIt may also cause failure of `equals()` comparisons if the `equals()` method doesn't accept subclasses as\nparameters.\n\nIn addition, before Java 9, double brace initialization couldn't be combined with the diamond operator since it was incompatible\nwith anonymous classes.\n\n**Example:**\n\n\n      List<Integer> list = new ArrayList<>() {{\n        add(1);\n        add(2);\n      }};\n\nAfter the quick-fix is applied:\n\n\n      List<Integer> list = new ArrayList<>();\n      list.add(1);\n      list.add(2);\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/problems/Literal.java",
      "language": "JAVA",
      "line": 20,
      "offset": 66,
      "length": 9,
      "code": {
        "startLine": 18,
        "length": 9,
        "offset": 109,
        "surroundingCode": "    String variableRegex = \"[a-zA-Z0-9]+\";\n\n    HashMap<BooleanOperation, Character> allowedOperations = new HashMap<>() {{\n        put(BooleanOperation.NEGATION, '-');\n        put(BooleanOperation.AND, '&');"
      }
    }
  ],
  "attributes": {
    "module": "java_thesis.main",
    "inspectionName": "DoubleBraceInitialization"
  },
  "hash": "6722f3e5d3e0fce9290289cced753edb7cdc17e0432c1885fffa6f9938ecb41e"
},{
  "tool": "Code Inspection",
  "category": "Initialization",
  "type": "Double brace initialization",
  "severity": "High",
  "comment": "Double brace initialization",
  "detailsInfo": "Reports [Double Brace Initialization](https://www.c2.com/cgi/wiki?DoubleBraceInitialization).\n\nDouble brace initialization may cause memory leaks when used in a non-static context because it creates an anonymous class\nthat will reference the surrounding object.\n\nCompared to regular initialization, double brace initialization provides worse performance since it requires loading an\nadditional class.\n\nIt may also cause failure of `equals()` comparisons if the `equals()` method doesn't accept subclasses as\nparameters.\n\nIn addition, before Java 9, double brace initialization couldn't be combined with the diamond operator since it was incompatible\nwith anonymous classes.\n\n**Example:**\n\n\n      List<Integer> list = new ArrayList<>() {{\n        add(1);\n        add(2);\n      }};\n\nAfter the quick-fix is applied:\n\n\n      List<Integer> list = new ArrayList<>();\n      list.add(1);\n      list.add(2);\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/problems/CnfFormula.java",
      "language": "JAVA",
      "line": 20,
      "offset": 66,
      "length": 9,
      "code": {
        "startLine": 18,
        "length": 9,
        "offset": 122,
        "surroundingCode": "    ArrayList<Literal> allLiterals = new ArrayList<>();\n\n    HashMap<BooleanOperation, Character> allowedOperations = new HashMap<>() {{\n        put(BooleanOperation.NEGATION, '-');\n        put(BooleanOperation.AND, '&');"
      }
    }
  ],
  "attributes": {
    "module": "java_thesis.main",
    "inspectionName": "DoubleBraceInitialization"
  },
  "hash": "fc36cc810c46f75914b34fb1c50f7b46809a5b1e8668a6efa82fa041962196da"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Use of obsolete collection type",
  "severity": "High",
  "comment": "Obsolete collection type `Stack` used",
  "detailsInfo": "Reports usages of `java.util.Vector`, `java.util.Hashtable` and `java.util.Stack`.\n\nUsages of these classes can often be replaced with usages of\n`java.util.ArrayList`, `java.util.HashMap` and `java.util.ArrayDeque` respectively.\nWhile still supported,\nthe former classes were made obsolete by the JDK1.2 collection classes, and should probably\nnot be used in new development.\n\n\nUse the **Ignore obsolete collection types where they are required** option to ignore any cases where the obsolete collections are used\nas method arguments or assigned to a variable that requires the obsolete type.\nEnabling this option may consume significant processor resources.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/reductions/CnfTo3CnfReduction.java",
      "language": "JAVA",
      "line": 23,
      "offset": 13,
      "length": 14,
      "code": {
        "startLine": 21,
        "length": 14,
        "offset": 146,
        "surroundingCode": "        for (ArrayList<Literal> clause : cnfFormula.clauses) {\n            // Here we will store copies of literals of current clause\n            Stack<Literal> clauseStack = new Stack<>();\n\n            // Put copies of literals"
      }
    }
  ],
  "attributes": {
    "module": "java_thesis.main",
    "inspectionName": "ObsoleteCollection"
  },
  "hash": "4238e0b8bf953f0fd9097c6aa16bbb5d79645d2ef1ed7f070596ce64fea48936"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Use of obsolete collection type",
  "severity": "High",
  "comment": "Obsolete collection type `Stack<>` used",
  "detailsInfo": "Reports usages of `java.util.Vector`, `java.util.Hashtable` and `java.util.Stack`.\n\nUsages of these classes can often be replaced with usages of\n`java.util.ArrayList`, `java.util.HashMap` and `java.util.ArrayDeque` respectively.\nWhile still supported,\nthe former classes were made obsolete by the JDK1.2 collection classes, and should probably\nnot be used in new development.\n\n\nUse the **Ignore obsolete collection types where they are required** option to ignore any cases where the obsolete collections are used\nas method arguments or assigned to a variable that requires the obsolete type.\nEnabling this option may consume significant processor resources.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/reductions/CnfTo3CnfReduction.java",
      "language": "JAVA",
      "line": 23,
      "offset": 46,
      "length": 7,
      "code": {
        "startLine": 21,
        "length": 7,
        "offset": 179,
        "surroundingCode": "        for (ArrayList<Literal> clause : cnfFormula.clauses) {\n            // Here we will store copies of literals of current clause\n            Stack<Literal> clauseStack = new Stack<>();\n\n            // Put copies of literals"
      }
    }
  ],
  "attributes": {
    "module": "java_thesis.main",
    "inspectionName": "ObsoleteCollection"
  },
  "hash": "cf8d1b2b6c38514c1a416f496f3be427fb4a48cfc82a20f13c93ac8276f9eaaf"
}]}